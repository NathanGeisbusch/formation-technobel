import {Text} from "@codemirror/state";

/** Input data generated by a parser and a builder that can be passed to a generator */
export type InputData = {
  [last: string]: InputData | string | number | boolean | null | (InputData | string | number | boolean | null)[]
}

/** Regex matching escaped string surrounded by double quotes. */
export const regexLiteralString = /^"(?:\\.|[^\\"])*"/;

/** Unescapes a text matching an escaped string surrounded by double quotes. */
export function unescapeString(match: string, offset: number): string {
  try {
    return JSON.parse(match);
  }
  catch(ex) {
    throw new CodeError('invalid regex (unescaped character)', offset, match);
  }
}

/**
 * Unescapes a text matching an escaped string surrounded by double quotes
 * and returns a regex matching strings starting with it.
 */
export function unescapeRegexString(match: string, offset: number): RegExp {
  const escaped = unescapeString(match, offset);
  try {
    return new RegExp(escaped.startsWith("^") ? escaped : `^${escaped}`, 'u');
  }
  catch(ex) {
    throw new CodeError('invalid regex', offset, match);
  }
}

/** Check if a an object has a property matching field */
export function hasProperty(object: Object, field: string|number|symbol): boolean {
  return Object.hasOwn(object, field);
}

/** Set value at property field of object */
export function setProperty(object: Object, field: string|number|symbol, value: any) {
  Object.defineProperty(object, field, {value,enumerable:true,writable:true});
}

// Functions to convert text to a specific case.
const letters = /[\p{L}\d]+/ug;
const nonLetters = /[^\p{L}\d]+/ug;
export function toTitleCase(text: string): string {
  return text[0].toUpperCase() + text.slice(1);
}
export function toKebabCase(text: string): string {
  return text.replace(nonLetters, '-');
}
export function toSnakeCase(text: string): string {
  return text.replace(nonLetters, '_');
}
export function toCamelCase(text: string): string {
  return text.match(letters)?.map(
    (word,i) => i === 0 ? word:toTitleCase(word)
  ).join('') || '';
}
export function toUpperCamelCase(text: string): string {
  return text.match(letters)?.map(toTitleCase).join('') || '';
}

/** Position in a source code */
export type Position = {
  offset: number;
  line: number;
  col: number;
}

/** Indicates that the line containing the error must be highlighted */
export const CodeErrorLine = Symbol('CodeErrorLine');
export type CodeErrorLine = typeof CodeErrorLine;

/** Syntax error happening during parsing */
export class CodeError extends Error {
  public constructor(
    message: string,
    public offset: number,
    public match?: string | number | CodeErrorLine,
  ) {
    super(message);
  }
}

/** Error happening during files generation */
export class GeneratorError extends Error {
  public constructor(message: string) {
    super(message);
  }
}

/** Position, type and message of a code error */
export interface CodeDiagnostic {
  from: number,
  to: number,
  severity: 'hint'|'info'|'warning'|'error',
  message: string
}
export type LintErrors = CodeDiagnostic|CodeDiagnostic[]|undefined;
export type Linter = (text: Text) => LintErrors;

/** Handle errors for code-editor by returning their position and message */
export function handleCodeErrors(text: Text, callback: () => void): LintErrors {
  try {
    callback();
  }
  catch(ex) {
    if(ex instanceof CodeError) {
      if(ex.match !== undefined) {
        if(ex.match === CodeErrorLine) {
          const {from, to} = text.lineAt(ex.offset);
          return {from, to, severity: 'error', message: ex.message};
        } else {
          const from = ex.offset;
          const to = from + (typeof ex.match === 'string' ? ex.match.length : ex.match);
          return {from, to, severity: 'error', message: ex.message};
        }
      } else {
        const from = ex.offset;
        const to = text.length;
        return {from, to, severity: 'error', message: ex.message};
      }
    }
  }
  return;
}
